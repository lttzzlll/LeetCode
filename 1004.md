### [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)

### Array, Sliding Window

```Python
class Solution:
    def longestOnes(self, A, K):
        start = 0
        for i, val in enumerate(A):
            if val == 0:
                K -= 1
            if K < 0:
                start += 1
                if A[start - 1] == 0:
                    K += 1
        return len(A) - start
```

这种解法可以获取最大值, 但是start, end的意义已经改变, 无法获取该最长区间.
所以需要一个算法, 既要获取最大值, 又要获取该最长区间.


```Python
class Solution:
    def longestOnes(self, A, K):
        start, total = 0, 0
        for i, val in enumerate(A):
            if val == 0:
                # 0-buffer缩小
                K -= 1
            if K < 0:
                # 已经没有0-buffer, 起点必须向右移动
                start += 1
                if A[start - 1] == 0:
                    # 起点位置是0, 0-buffer不再包含这个元素, 因此可以扩大
                    K += 1
            cur = i - start + 1
            if cur > total:
                total = cur
                print(A[start: i + 1])
        return total
```

这种方式便可以记录最长区间.

这道题的思路其实很简单: 起点默认是0,终点默认是遍历过程中的i,如果遇到了0, 0-buffer的
尺寸K减小, 如果K == 0, 说明 0-buffer已满, 没有空位置再放置一个0了. 如果K < 0, 则起点
必须向右移动了, 因为0-buffer已经没有空位置了. 此时, 需要判断起点位置是不是0, 如果是0, 则0-buffer可以回收一个位置, 对应K增大.如果起点位置不是0, 则0-buffer无法回收该位置, 这种情况下, 终点i每向右移动一个位置, 起点start也必须向右移动一个位置.
